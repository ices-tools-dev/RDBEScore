#' Generate any missing SS rows.
#' When FOcatchReg=="All" it is expected that SScatchFraction is either "Catch"
#' OR "Lan"+"Dis". In the latter case, if one is missing the other is to
#' be assumed 0.
#' This function generates SS rows for any missing catch fractions.
#'
#' @param RDBESDataObject A valid RDBESDataObject
#' @param speciesListName The name of the Species List you want to use
#' for any SS rows that are created.
#' @param verbose (Optional) Set to TRUE if you want informative text printed
#' out, or FALSE if you don't.  The default is FALSE.
#' @param strict (Optional) This function validates its input data - should
#' the validation be strict? The default is TRUE.
#'
#' @return A data table of SS data with any missing rows added
#' @export
#'
#' @examples
generateMissingSSRows <- function(RDBESDataObject,
                                  speciesListName,
                                  verbose = FALSE,
                                  strict = TRUE){


  # Check we have a valid RDBESDataObject before doing anything else
  validateRDBESDataObject(RDBESDataObject,
                          verbose = verbose,
                          strict = strict)

  # Check we have some SL data
  if (length(RDBESDataObject[["SL"]]) <= 1 ){
    if (is.null(RDBESDataObject[["SL"]])){
      stop("SL data does not exist in the input data but it is required")
    }
  }

  # Check we have some SS data
  if (length(RDBESDataObject[["SS"]]) <= 1 ){
    if (is.null(RDBESDataObject[["SS"]])){
      stop("SS data does not exist in the input data but it is required")
    }
  }

  # Check we have some FO data
  if (length(RDBESDataObject[["FO"]]) <= 1 ){
    if (is.null(RDBESDataObject[["FO"]])){
      stop("FO data does not exist in the input data but it is required")
    }
  }

  # TODO Check if speciesListName exists for this year and country
  # For the time being just check if it exists at all

  if (!speciesListName %in% unique(RDBESDataObject[["SL"]]$SLspeclistName)){
    stop("The requested species list name does not exist in the input data")
  }

  # For testing
  #RDBESDataObject <- importRDBESDataCSV(rdbesExtractPath = "./tests/testthat/h1_v_1_19_18")
  # Only use a subset of the test data
  #RDBESDataObject <- filterRDBESDataObject(RDBESDataObject, c("DEstratumName"), c("DE_stratum1_H1", "DE_stratum2_H1", "DE_stratum3_H1"))
  #RDBESDataObject <- findAndKillOrphans(RDBESDataObject, verbose = FALSE)
  #speciesListName <- "StupidTest"
  #verbose <- TRUE

  #take a copy of the data so we don't change the original
  myFO <- data.table::copy(RDBESDataObject[["FO"]])
  mySS <- data.table::copy(RDBESDataObject[["SS"]])

  # We only care about sampled FO records
  myFO <- myFO[myFO$FOsamp == "Y",]

  # We want to check SS records that are linked to FO
  #mySSLinked <- mySS[!is.na(mySS$FOid),]
  # We only want to check SS records that are linked to the supplied, sampled FO data
  mySSLinked <- mySS[!is.na(mySS$FOid) & mySS$FOid %in% myFO$FOid,]

  if (verbose){
    print(paste0(nrow(myFO)," rows of FO data have been sampled in the input data"))
    print(paste0(nrow(mySSLinked)," rows of SS data are linked to the sampled FO records in the input data"))
  }

  # FO All
  # TODO Change FO "All" rows to "Lan" and "Dis" so we can try and match SS

  # FOr testing
  #myFO$FOcatReg <- "Dis"
  #mySSLinked[1:2,"SScatchFra"] <- "Dis"
  #myFO[50:51,"FOcatReg"] <- "Dis"

  # FO Lan
  if (verbose){
    print("Checking FOcatReg = 'Lan'")
  }
  SSLanMissing <- getMissingSSCatchFraction(myFO, mySSLinked, "Lan", verbose)
  SSLanToAdd <- generateSSRows(SSLanMissing,
                                 speciesListName,
                                 "Lan")
  if (verbose){
    print(paste0(nrow(SSLanToAdd)," landing rows added to SS (generated by FOcatReg = 'Lan')"))
  }

  # FO Dis
  if (verbose){
    print("Checking FOcatReg = 'Dis'")
  }
  SSDisMissing <- getMissingSSCatchFraction(myFO, mySSLinked, "Dis", verbose)
  SSDisToAdd <- generateSSRows(SSDisMissing,
                               speciesListName,
                               "Dis")
  if (verbose){
    print(paste0(nrow(SSDisToAdd)," discard rows added to SS (generated by FOcatReg = 'Dis')"))
  }

  # FO None
  # Do nothing :-)


  # Return SS with any extra rows
  SStoAdd <- rbind(SSLanToAdd, SSDisToAdd)
  if (verbose){
    print(paste0(nrow(SStoAdd)," rows of SS data have been added"))
  }
  SStoReturn <- rbind(mySS,SStoAdd)
  if (verbose){
    print(paste0(nrow(SStoReturn)," rows of SS data will be returned"))
  }
  SStoReturn

}

#' Find which FO rows are not matching SS
#'
#' @param FOdata
#' @param SSdata
#' @param catchFra
#'
#' @return Vector of FOids that aren't matching SS rows
getMissingSSCatchFraction <- function(FOdata, SSdata, catchFra, verbose){

  # For testing
  #FOdata <- myFO
  #SSdata <- mySSLinked
  #catchFra <- 'Lan'


  myFOFraction <- FOdata[FOdata$FOcatReg == catchFra,]
  if (verbose){
    print(paste0("Processing ",nrow(myFOFraction),
                               " rows of FO data for FOcatReg = ", catchFra))
  }
  myFOSS <- dplyr::left_join(myFOFraction,
                                SSdata,
                                dplyr::join_by("FOid" == "FOid",
                                               "FOcatReg" == "SScatchFra")
                             )
  mySSFractionMissing <- myFOSS[is.na(myFOSS$SSid),]

  mySSFractionMissing$FOid

}

#' Private function to generate SS rows
#'
#' @param FOids Vector of FOids
#' @param speciesListName  Name of the species list
#' @param catchFra The catch fraction to create
#'
#' @return SS data frame
#'
generateSSRows <- function(FOids, speciesListName, catchFra){

  if (length(FOids) >0){
    myNAs <- replicate(length(FOids),NA)
    specListNames <- replicate(length(FOids),speciesListName)
    catchFractions <- replicate(length(FOids),catchFra)
  } else {
    myNAs <- integer()
    specListNames <- character()
    catchFractions <- character()
  }

    data.frame(SSid = myNAs,
               LEid = myNAs,
               FOid = FOids, # FOids
               TEid = myNAs,
               FTid = myNAs,
               SLid = myNAs,
               OSid = myNAs,
               SSrecType = myNAs,
               SSseqNum = myNAs,
               SSstratification = myNAs,
               SSstratumName = myNAs,
               SSclustering = myNAs,
               SSclusterName = myNAs,
               SSobsActTyp = myNAs,
               SScatchFra = catchFractions, # Catch Fraction
               SSobsTyp = myNAs,
               SSsampler = myNAs,
               SSspecListName = specListNames, # Species list name
               SSuseCalcZero = myNAs,
               SStimeTotal = myNAs,
               SStimeSamp = myNAs,
               SSnumTotal = myNAs,
               SSnumSamp = myNAs,
               SSselProb = myNAs,
               SSincProb = myNAs,
               SSselectMeth = myNAs,
               SSunitName = myNAs,
               SSselectMethCluster = myNAs,
               SSnumTotalClusters = myNAs,
               SSnumSampClusters = myNAs,
               SSselProbCluster = myNAs,
               SSincProbCluster = myNAs,
               SSsamp = myNAs,
               SSnoSampReason = myNAs,
               SSnonRespCol = myNAs,
               SSauxVarTot = myNAs,
               SSauxVarValue = myNAs,
               SSauxVarName = myNAs,
               SSauxVarUnit = myNAs )


}
