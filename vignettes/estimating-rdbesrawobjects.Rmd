---
title: "Estimating Population parameters from RDBESRawObjects"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Estimating RDBESRawObjects}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


## Introduction 

The aim of this document is to illustrate how population parameters like total and mean can be estimated using the **estimMC(...)** function.

```{r}
library(icesRDBES)
```

## Prerequisites

First we'll load some example data from the RDBES and check it's valid.  It's a good idea to check your RDBESRawObjects are valid after any manipulations you perform.

```{r load}
h1d <- createRDBESRawObject(rdbesExtractPath = "..\\tests\\testthat\\h1_v_1_19")
h1dValid <- validateRDBESRawObject(h1d, verbose = FALSE)

```


## Functions

Functions for demonstrating multi-level design 



```{r}
getEstim<-function(id, data, cols, parentIdCol){
      data <- data[get(parentIdCol) == id, ]
      y <- data[, get(cols["y"])]
      sampled <-data[, get(cols["numSampledCol"])]
      total <- data[, get(cols["numTotalCol"])]
      
      selMethod <- unique(data[, get(cols["selMethodCol"])])
      if(length(selMethod)!=1){
        stop(paste("Can't deal with multiple selection methods.",tblName, 
                   "has methods:", paste0(selMethod,collapse = ", ")))
        }
      estim <- estimMC(y, sampled, total, selMethod)
      estim
      
    }
```


```{r}
getLastEstimRes<-function(estimRes){
  if(is.null(estimRes$prevStage))stop("no estim found")
  if(is.list(estimRes$estim)) return(estimRes$estim)
  getLastEstimRes(estimRes$prevStage)
  
}
```


```{r estimate}
estimate<-function(tbl, estimRes, target){
  parentIdCol <- estimRes$parentIdCol
  ids <- estimRes$ids
  tblName <- unique(tbl[[colnames(tbl)[grepl("recType$", colnames(tbl))]]])
  if(length(tblName)>1){stop("Mixed table")}
  cols <- icesRDBES:::getColnames(tblName)
  missingCols <- setdiff(cols, colnames(tbl))
  isTarget  <- length(setdiff(target, colnames(tbl))) == 0
  data <- tbl[get(parentIdCol) %in% ids,]
  data$dummy <- 1
  estim <- NA
  if(length(missingCols) == 0){
     #TODO stratification
     #TODO type of measure should also be selected 
     #NBfor sample/test data is all the same "Age"
     stratified <- unique(data[,get(cols["stratifiedCol"])])
     if(length(stratified)!= 1){stop("Can't handle mixed Y & N stratification")}
     #if(stratified == "Y"){stop("Can't handle stratification Y")}
     if(stratified == "Y"){data <- data[get(cols["stratumCol"]) %in% data[1,get(cols["stratumCol"])],]}
    if(isTarget){cols <- c(cols,y=target)}
    if(!isTarget){cols <- c(cols, y="dummy")}
    if(!is.numeric(data[, get(cols["y"])])){
        warning("Target is not numeric! converting!")
        data[, cols["y"] := as.numeric(data[, get(cols["y"])])]
    }
    estims <- lapply(ids, getEstim, data = data, cols = cols, parentIdCol = parentIdCol)
    estim<-aggLevelEstimations(estims)
    if(!is.null(estimRes$prevStage)){
      lastEstim <- getLastEstimRes(estimRes)
      estim$est.total <- estim$est.total * lastEstim$est.total
   
    }
  }
  return(list(parentIdCol=cols["idCol"],
              ids=data[, get(cols["idCol"])],
              tbl=tblName,
              estim=estim, prevStage=estimRes ))
  
  }
```

## Func

```{r aggLevelEstimations}
#TODO the big question is how to aggregate these estimations into one  especially PI
aggLevelEstimations <- function(estims){
  return(list(
  est.total = mean(sapply(estims, function(x){x$est.total})),
  est.mean = mean(sapply(estims, function(x){x$est.mean})),
  var.total = mean(sapply(estims, function(x){x$var.total})),
  var.mean = mean(sapply(estims, function(x){x$var.mean})),
  PI = Reduce(`+`,lapply(estims, function(x){x$PI})) #sum the PI, keep structure
  ))
}
```

```{r}
gatherEstimates<-function(tbls, estimRes, target){
  if(length(tbls) == 0) return(NULL)
  tbl <- tbls[[1]]
  tbls[[1]]<-NULL
  if(target %in% colnames(tbl)) return(estimate(tbl, estimRes, target))
  estimRes <- estimate(tbl, estimRes, target)
  gatherEstimates(tbls,estimRes, target)
}
```


## Single level Multiple Count Estimator

Let's first estimate the last level values for a single VSid so that estimation is done for each top level record (i.e. as the data is)
```{r}
FMidSel <- "254505"
BV <- h1d$BV[h1d$BV$FMid == FMidSel,]

estimMC(as.numeric(BV$BVvalueMeas),
        BV$BVnumSamp,
        BV$BVnumTotal, 
        method=unique(BV$BVselectMeth))
```

## Multi-level Multiple Count Estimator

```{r}
# a few convenience functions to check results
check<-function(x,e, name ="", digits=2, show=F){
  if(show){
    if(round(x,digits*2) != round(e,digits*2)){
      warning(paste(name,"expected:", round(e, digits), "!=", round(x, digits)),
              call. = F)
    }else{
      cat(paste(name,"expected:", round(e, digits), "==", round(x, digits), "\n"))
    }
  }else{
    
    testthat::expect_equal(x,e)
    }
}
warning("The expected variances are likely wrong!", call. = F)

checkEstimates <- function(tblName, hd, startEstim, propSampled, ...){
  Ty <- paste0(tblName, "y")
  numStages <- which(names(hd) == tblName) #from A to B
  prevRows <- nrow(hd[[1]])^(numStages-2)
  prevID <- paste0(names(hd)[numStages-1],"id")
  res<-gatherEstimates(tbls=hd, startEstim, target =Ty)
  
 
  b <- hd[[tblName]][hd[[tblName]][[prevID]] %in% c(1:prevRows), ]
  #TODO the variance checks might be misleading repair
  if(propSampled !=1){
    }
  
  expTotal <- sum(b[[Ty]])*((1/propSampled)^numStages)
  expVar <- ifelse(propSampled == 1, 0, var(b[[Ty]]))
  expVarTot <- expVar * ((1/propSampled)^numStages)
  check(res$estim$est.mean, mean(b[[Ty]]), "Mean", ...)
  check(res$estim$var.mean, expVar, "Var mean", ...)
  check(res$estim$est.total, expTotal,"Total",  ...)
  check(res$estim$var.total, expVarTot, "Var total", ...)
}

```

### Simulated data

```{r}
#keep results consistent
set.seed(1234)
```


#### CENSUS

```{r}

propSampled <- 1
hd<-generateTestTbls(LETTERS[1:5], propSamp = propSampled)
startEstim <- list(parentIdCol = "Aid", ids=c(1))

for(L in LETTERS[2:5]){
  cat(paste0("level ", L, ":\n"))
  checkEstimates(L, hd, startEstim, propSampled, show=F)
  cat("\n")
}

```



#### SRSWOR

##### All sampled
```{r}

propSampled <- 1
startEstim <- list(parentIdCol = "Aid", ids=c(1))
hd<-generateTestTbls(LETTERS[1:5], selMeth="SRSWOR",propSamp = propSampled)

for(L in LETTERS[2:5]){
  cat(paste0("level ", L, ":\n"))
  checkEstimates(L, hd, startEstim, propSampled, show=T)
  cat("\n")
}

```

##### 50% sampled

```{r}

propSampled <- 0.5
startEstim <- list(parentIdCol = "Aid", ids=c(1))
hd<-generateTestTbls(LETTERS[1:5], selMeth="SRSWOR",propSamp = propSampled)


for(L in LETTERS[2:5]){
  cat(paste0("level ", L, ":\n"))
  checkEstimates(L, hd, startEstim, propSampled, show=T)
  cat("\n")
}

```


##### 10% sampled

```{r}

propSampled <- 0.1
startEstim <- list(parentIdCol = "Aid", ids=c(1))
hd<-generateTestTbls(LETTERS[1:5], selMeth="SRSWOR",propSamp = propSampled, rows = 5)


for(L in LETTERS[2:5]){
  cat(paste0("level ", L, ":\n"))
  checkEstimates(L, hd, startEstim, propSampled, show=T)
  cat("\n")
}

```

#### SRSWR
##### All sampled
```{r}
set.seed(1234)
propSampled <- 1
startEstim <- list(parentIdCol = "Aid", ids=c(1))
hd<-generateTestTbls(LETTERS[1:5], selMeth="SRSWR",propSamp = propSampled)

for(L in LETTERS[2:5]){
  cat(paste0("level ", L, ":\n"))
  checkEstimates(L, hd, startEstim, propSampled, show=T)
  cat("\n")
}

```

##### 50% sampled

```{r}
set.seed(1234)
propSampled <- 0.5
startEstim <- list(parentIdCol = "Aid", ids=c(1))
hd<-generateTestTbls(LETTERS[1:5], selMeth="SRSWR",propSamp = propSampled)


for(L in LETTERS[2:5]){
  cat(paste0("level ", L, ":\n"))
  checkEstimates(L, hd, startEstim, propSampled, show=T)
  cat("\n")
}

```

##### 10% sampled

```{r}
propSampled <- 0.1
startEstim <- list(parentIdCol = "Aid", ids=c(1))
hd<-generateTestTbls(LETTERS[1:5], selMeth="SRSWR",propSamp = propSampled, rows=5)

for(L in LETTERS[2:5]){
  cat(paste0("level ", L, ":\n"))
  checkEstimates(L, hd, startEstim, propSampled, show=T)
  cat("\n")
}

```


### Actual data


For lower hierarchy tables the number of sampled and measured total 
```{r}
estimTables <- tablesInRDBESHierarchies$H1[3:9]
estimTables
```

```{r}
head(h1d[[estimTables[1]]])
```

```{r}
#fixBVtype for value measured
#h1d$BV$BVvalueMeas <- as.numeric(h1d$BV$BVvalueMeas)
```

So we are estimating for a single Vessel the "BVvalueMeas" 

```{r}
startEstim <- list(parentIdCol = "VSid", ids=c(4874))
res<-gatherEstimates(tbls=h1d[estimTables], startEstim, target = "BVvalueMeas")

warning("Variance is not corrected for  upper levels for variance")
res$estim$est.mean
res$estim$var.mean
res$estim$est.total
res$estim$var.total
```

As we have sampled all items in this level we can see what the mean looks like in the actual data
```{r}
mean(as.numeric(h1d$BV[BVid %in% res$ids, BVvalueMeas]))
var(as.numeric(h1d$BV[BVid %in% res$ids, BVvalueMeas]))
sum(as.numeric(h1d$BV[BVid %in% res$ids, BVvalueMeas]))
```

In any case all of the previous stages are included hierarchically in the result. What is needed is the probability matrix for variance and total estimation at the last level. For the 2. level the PI is:
```{r}
res$prevStage$prevStage$prevStage$prevStage$prevStage$tbl
res$prevStage$prevStage$prevStage$prevStage$prevStage$estim$PI

```
It seems that for SRS the PI is homogeneous so can be converted to single number (both for SRSWR and SRSWOR) Let's see also the table as it looks at second level

```{r}
ids <- res$prevStage$prevStage$prevStage$prevStage$prevStage$ids
tblID <- res$prevStage$prevStage$prevStage$prevStage$prevStage$tbl
idCol <- res$prevStage$prevStage$prevStage$prevStage$prevStage$parentIdCol
tbl<-h1d[[tblID]]
tbl[get(idCol) %in% ids,]
```


```{r}
#END
```

