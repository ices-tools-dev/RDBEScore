---
title: "Estimating Population parameters from RDBESRawObjects"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Estimating RDBESRawObjects}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


## Introduction 

The aim of this document is to illustrate how population parameters like total and mean can be estimated using the **estimMC(...)** function.

```{r}
library(icesRDBES)
```

## Prerequisites

First we'll load some example data from the RDBES and check it's valid.  It's a good idea to check your RDBESRawObjects are valid after any manipulations you perform.

```{r load}
h1d <- createRDBESRawObject(rdbesExtractPath = ".\\tests\\testthat\\h1_v_1_19")
h1dValid <- validateRDBESRawObject(h1d, verbose = FALSE)

```


## Functions

Functions for demonstrating multi-level design 



```{r}
getColnames <- function(tblName){
  idCol <- paste0(tblName,"id")
  numSampledCol <- paste0(tblName,"numSamp")
  numTotalCol <- paste0(tblName,"numTotal")
  selMethodCol <- paste0(tblName,"selectMeth")
  stratumCol <- paste0(tblName,"stratumName")
  c(idCol = idCol,
    numSampledCol=numSampledCol,
    numTotalCol=numTotalCol,
    selMethodCol = selMethodCol,
    stratumCol = stratumCol)
}
```

```{r}
getEstim<-function(id, data, cols, parentIdCol){
      data <- data[get(parentIdCol) == id, ]
      y <- data[, get(cols["y"])]
      sampled <-data[, get(cols["numSampledCol"])]
      total <- data[, get(cols["numTotalCol"])]
      
      selMethod <- unique(data[, get(cols["selMethodCol"])])
      if(length(selMethod)!=1){
        stop(paste("Can't deal with multiple selection methods.",tblName, 
                   "has methods:", paste0(selMethod,collapse = ", ")))
        }
      estim <- estimMC(y, sampled, total, selMethod)
      estim
      
    }
```


```{r}
getLastEstimRes<-function(estimRes){
  if(is.null(estimRes$prevStage))stop("no estim found")
  if(is.list(estimRes$estim)) return(estimRes$estim)
  getLastEstimRes(estimRes$prevStage)
  
}
```


```{r estimate}
estimate<-function(tbl, estimRes, target){
  parentIdCol <- estimRes$parentIdCol
  ids <- estimRes$ids
  tblName <- unique(tbl[[colnames(tbl)[grepl("recType$", colnames(tbl))]]])
  if(length(tblName)>1){stop("Mixed table")}
  cols <- getColnames(tblName)
  missingCols <- setdiff(cols, colnames(tbl))
  isTarget  <- length(setdiff(target, colnames(tbl))) == 0
  data <- tbl[get(parentIdCol) %in% ids,]
  data$dummy <- 1
  estim <- NA
  method<-NA
  if(length(missingCols) == 0){
     #TODO stratification
     #TODO type of measure should also be selected for sample data is all "Age"
     stratums <- unique(data[,get(cols["stratumCol"])])
     data <- data[get(cols["stratumCol"]) %in% stratums[1],]
    if(isTarget){cols <- c(cols,y=target)}
    if(!isTarget){cols <- c(cols, y="dummy")}
    if(!is.numeric(data[, get(cols["y"])])){
        warning("Target is not numeric! converting!")
        data[, cols["y"] := as.numeric(data[, get(cols["y"])])]
    }
    estims <- lapply(ids, getEstim, data = data, cols = cols, parentIdCol = parentIdCol)
    estim<-aggLevelEstimations(estims)
   
  } 
  return(list(parentIdCol=cols["idCol"],
              ids=data[, get(cols["idCol"])],
              tbl=tblName,
              estim=estim, prevStage=estimRes ))
  
  }
```


```{r aggLevelEstimations}
#TODO the big question is how to aggregate these estimations into one  especially PI
aggLevelEstimations <- function(estims){
  return(list(
  est.total = sum(sapply(estims, function(x){x$est.total})),
  est.mean = mean(sapply(estims, function(x){x$est.mean})),
  var.total = sum(sapply(estims, function(x){x$var.total})),
  var.mean = mean(sapply(estims, function(x){x$var.mean})),
  PI = mean(sapply(estims, function(x){x$PI}))
  ))
}
```

```{r}
gatherEstimates<-function(tbls, estimRes, target){
  if(length(tbls) == 0) return(NULL)
  tbl <- tbls[[1]]
  tbls[[1]]<-NULL
  if(target %in% colnames(tbl)) return(estimate(tbl, estimRes, target))
  estimRes <- estimate(tbl, estimRes, target)
  gatherEstimates(tbls,estimRes, target)
}
```


## Single level Multiple Count Estimator

Let's first estimate the last level values for a single VSid so that estimation is done for each top level record (i.e. as the data is)
```{r}
FMidSel <- "254505"
BV <- h1d$BV[h1d$BV$FMid == FMidSel,]

estimMC(as.numeric(BV$BVvalueMeas),
        BV$BVnumSamp,
        BV$BVnumTotal, 
        method=unique(BV$BVselectMeth))
```

## Multi-level Multiple Count Estimator

### Simulated data



```{r}
check<-function(x,e, digits=2, show=T){
  if(show){
    if(x != e){
      warning(paste("Expected:", round(e, digits), "!=", round(x, digits)),
              call. = F)
    }else{
      cat(paste("Expected:", round(e, digits), "==", round(x, digits), "\n"))
    }
  }else{
    if(x != e){
      warning(paste("Expected:", round(e, digits), "!=", round(x, digits)),
              call. = T)
    }
  }
}
```


```{r}
makeTbl <- function(tblName, prevTbls = list(), rows=4, proportionSampled=0.5,
                    method="CENSUS", stratum="U", mean=5){
  cols <- getColnames(tblName)
  prevTbl <- NULL
  times<-rows
  total<-rows/proportionSampled
  if(method=="CENSUS"){total<-rows}
  
  if(length(prevTbls)>0){prevTbl <- prevTbls[[length(prevTbls)]]}
  if(!is.null(prevTbl)){
    times<- rows*nrow(prevTbl)
    #take the first id column
    cols <- c(cols, grep("id$", colnames(prevTbl), value = TRUE)[1])
  }
  data <- list(1:times,
               rep(rows, times),
               rep(total, times),
               rep(method,times),
               rep(stratum,times)
               )
  if(!is.null(prevTbl)){
    ids <- prevTbl[,get(cols[length(cols)])]
    data[[length(cols)]] <- rep(ids, each=rows)
    }
  names(data)<-cols
  data[[paste0(tblName,"y")]] <- rnorm(times, mean=mean)
  data[[paste0(tblName,"recType")]] <- tblName
  data.table::as.data.table(data)
}
makeTbls<-function(tbls, prevTbls=list(), ...){
  tbl<-makeTbl(tbls[1], prevTbls, ...)
  prevTbls[[tbls[1]]] <- tbl
  if(length(tbls)==1){return(prevTbls)}
  tbls<-tbls[tbls != tbls[1]]
  makeTbls(tbls, prevTbls, ...)
}
```

#### CENSUS

```{r}
#tbls <- paste0("lvl", c("I", "II", "III"))
set.seed(1234)
propSampled <- 1
hd<-makeTbls(LETTERS[1:5], method="CENSUS", proportionSampled = propSampled)
```


```{r}
startEstim <- list(parentIdCol = "Aid", ids=c(1))
```


```{r}
res<-gatherEstimates(tbls=hd, startEstim, target = "By")
b <- hd$B[hd$B$Aid == 1, ]

check(res$estim$est.mean, mean(b$By))
check(res$estim$var.mean, 0)
check(res$estim$est.total, sum(b$By*1/propSampled))
check(res$estim$var.total, 0)
nrow(b)
```


```{r}
res<-gatherEstimates(tbls=hd, startEstim, target = "Cy")
b <- hd$C[hd$C$Bid %in% c(1:4), ]
check(res$estim$est.mean, mean(b$Cy))
check(res$estim$var.mean, 0)
check(res$estim$est.total, sum(b$Cy)*1/propSampled)
check(res$estim$var.total, 0)
nrow(b)
```


```{r}
res<-gatherEstimates(tbls=hd, startEstim, target = "Dy")

b <- hd$D[hd$D$Cid %in% c(1:16), ]
check(res$estim$est.mean, mean(b$Dy))
check(res$estim$var.mean, 0)
check(res$estim$est.total, sum(b$Dy)*1/propSampled)
check(res$estim$var.total, 0)
nrow(b)
```

```{r}
Ty <- "Ey"
res<-gatherEstimates(tbls=hd, startEstim, target =Ty)

b <- hd$E[hd$E$Did %in% c(1:64), ]
check(res$estim$est.mean, mean(b[[Ty]]))
check(res$estim$var.mean, 0)
check(res$estim$est.total, sum(b[[Ty]])*1/propSampled)
check(res$estim$var.total, 0)
nrow(b)
```


```{r}
#tbls <- paste0("lvl", c("I", "II", "III"))
```


#### SRSWOR

```{r}

set.seed(1234)
propSampled <- 1
startEstim <- list(parentIdCol = "Aid", ids=c(1))
hd<-makeTbls(LETTERS[1:5], method="SRSWOR", proportionSampled = propSampled)
```


```{r}
res<-gatherEstimates(tbls=hd, startEstim, target = "By")
b <- hd$B[hd$B$Aid == 1, ]

check(res$estim$est.mean, mean(b$By))
check(res$estim$var.mean, 0)
check(res$estim$est.total, sum(b$By*1/propSampled))
check(res$estim$var.total, 0)
nrow(b)
```


```{r}
res<-gatherEstimates(tbls=hd, startEstim, target = "Cy")
b <- hd$C[hd$C$Bid %in% c(1:4), ]
check(res$estim$est.mean, mean(b$Cy))
check(res$estim$var.mean, 0)
check(res$estim$est.total, sum(b$Cy)*1/propSampled)
check(res$estim$var.total, 0)
nrow(b)
```


```{r}
res<-gatherEstimates(tbls=hd, startEstim, target = "Dy")

b <- hd$D[hd$D$Cid %in% c(1:16), ]
check(res$estim$est.mean, mean(b$Dy))
check(res$estim$var.mean, 0)
check(res$estim$est.total, sum(b$Dy)*1/propSampled)
check(res$estim$var.total, 0)
nrow(b)
```

```{r}
Ty <- "Ey"
res<-gatherEstimates(tbls=hd, startEstim, target =Ty)

b <- hd$E[hd$E$Did %in% c(1:64), ]
check(res$estim$est.mean, mean(b[[Ty]]))
check(res$estim$var.mean, 0)
check(res$estim$est.total, sum(b[[Ty]])*1/propSampled)
check(res$estim$var.total, 0)
nrow(b)
```
```{r}

set.seed(1234)
propSampled <- 0.5
startEstim <- list(parentIdCol = "Aid", ids=c(1))
hd<-makeTbls(LETTERS[1:5], method="SRSWOR", proportionSampled = propSampled)
```


```{r}
res<-gatherEstimates(tbls=hd, startEstim, target = "By")
b <- hd$B[hd$B$Aid == 1, ]

check(res$estim$est.mean, mean(b$By))
check(res$estim$var.mean, 0)
check(res$estim$est.total, sum(b$By*1/propSampled))
check(res$estim$var.total, 0)
nrow(b)
```


```{r}
res<-gatherEstimates(tbls=hd, startEstim, target = "Cy")
b <- hd$C[hd$C$Bid %in% c(1:4), ]
check(res$estim$est.mean, mean(b$Cy))
check(res$estim$var.mean, 0)
check(res$estim$est.total, sum(b$Cy)*1/propSampled)
check(res$estim$var.total, 0)
nrow(b)
```


```{r}
res<-gatherEstimates(tbls=hd, startEstim, target = "Dy")

b <- hd$D[hd$D$Cid %in% c(1:16), ]
check(res$estim$est.mean, mean(b$Dy))
check(res$estim$var.mean, 0)
check(res$estim$est.total, sum(b$Dy)*1/propSampled)
check(res$estim$var.total, 0)
nrow(b)
```

```{r}
Ty <- "Ey"
res<-gatherEstimates(tbls=hd, startEstim, target =Ty)

b <- hd$E[hd$E$Did %in% c(1:64), ]
check(res$estim$est.mean, mean(b[[Ty]]))
check(res$estim$var.mean, 0)
check(res$estim$est.total, sum(b[[Ty]])*1/propSampled)
check(res$estim$var.total, 0)
nrow(b)
```


#### SRSWR

```{r}

set.seed(1234)
propSampled <- 0.1
startEstim <- list(parentIdCol = "Aid", ids=c(1))
hd<-makeTbls(LETTERS[1:5], method="SRSWR", proportionSampled = propSampled)
```


```{r}
res<-gatherEstimates(tbls=hd, startEstim, target = "By")
b <- hd$B[hd$B$Aid == 1, ]

check(res$estim$est.mean, mean(b$By))
check(res$estim$var.mean, 0)
check(res$estim$est.total, sum(b$By*1/propSampled))
check(res$estim$var.total, 0)
nrow(b)
```


```{r}
res<-gatherEstimates(tbls=hd, startEstim, target = "Cy")
b <- hd$C[hd$C$Bid %in% c(1:4), ]
check(res$estim$est.mean, mean(b$Cy))
check(res$estim$var.mean, 0)
check(res$estim$est.total, sum(b$Cy)*1/propSampled)
check(res$estim$var.total, 0)
nrow(b)
```


```{r}
res<-gatherEstimates(tbls=hd, startEstim, target = "Dy")

b <- hd$D[hd$D$Cid %in% c(1:16), ]
check(res$estim$est.mean, mean(b$Dy))
check(res$estim$var.mean, 0)
check(res$estim$est.total, sum(b$Dy)*1/propSampled)
check(res$estim$var.total, 0)
nrow(b)
```

```{r}
Ty <- "Ey"
res<-gatherEstimates(tbls=hd, startEstim, target =Ty)

b <- hd$E[hd$E$Did %in% c(1:64), ]
check(res$estim$est.mean, mean(b[[Ty]]))
check(res$estim$var.mean, 0)
check(res$estim$est.total, sum(b[[Ty]])*1/propSampled)
check(res$estim$var.total, 0)
nrow(b)
```


### Actual data


For lower hierarchy tables the number of sampled and measured total 
```{r}
estimTables <- tablesInRDBESHierarchies$H1[3:9]
estimTables
```

```{r}
head(h1d[[estimTables[1]]])
```

```{r}
#fixBVtype for value measured
#h1d$BV$BVvalueMeas <- as.numeric(h1d$BV$BVvalueMeas)
```

So we are estimating for a single Vessel the "BVvalueMeas" 

```{r}
startEstim <- list(parentIdCol = "VSid", ids=c(4874))
res<-gatherEstimates(tbls=h1d[estimTables], startEstim, target = "BVvalueMeas")

warning("Variance is not corrected for  upper levels for variance")
res$estim$est.mean
res$estim$var.mean
res$estim$est.total
res$estim$var.total
```

As we have sampled all items in this level we can see what the mean looks like in the actual data
```{r}
mean(as.numeric(h1d$BV[BVid %in% res$ids, BVvalueMeas]))
var(as.numeric(h1d$BV[BVid %in% res$ids, BVvalueMeas]))
sum(as.numeric(h1d$BV[BVid %in% res$ids, BVvalueMeas]))
```

In any case all of the previous stages are included hierarchically in the result. What is needed is the probability matrix for variance and total estimation at the last level. For the 2. level the PI is:
```{r}
res$prevStage$prevStage$prevStage$prevStage$prevStage$tbl
res$prevStage$prevStage$prevStage$prevStage$prevStage$estim$PI

```
It seems that for SRS the PI is homogeneous so can be converted to single number (both for SRSWR and SRSWOR) Let's see also the table as it looks at second level

```{r}
ids <- res$prevStage$prevStage$prevStage$prevStage$prevStage$ids
tblID <- res$prevStage$prevStage$prevStage$prevStage$prevStage$tbl
idCol <- res$prevStage$prevStage$prevStage$prevStage$prevStage$parentIdCol
tbl<-h1d[[tblID]]
tbl[get(idCol) %in% ids,]
```


```{r}
#END
```

