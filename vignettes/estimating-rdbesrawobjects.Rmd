---
title: "Estimating Population parameters from RDBESRawObjects"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Estimating RDBESRawObjects}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


## Introduction 

The aim of this document is to illustrate how population parameters like total and mean can be estimated using the **estimMC(...)** function.

```{r}
library(icesRDBES)
```

## Prerequisites

First we'll load some example data from the RDBES and check it's valid.  It's a good idea to check your RDBESRawObjects are valid after any manipulations you perform.

```{r load}
h1d <- createRDBESRawObject(rdbesExtractPath = ".\\tests\\testthat\\h1_v_1_19")
h1dValid <- validateRDBESRawObject(h1d, verbose = FALSE)

```


## Single level Multiple Count Estimator

Let's first estimate the last level values for a single VSid so that estimation is done for each top level record (i.e. as the data is)
```{r}
FMidSel <- "254505"
BV <- h1d$BV[h1d$BV$FMid == FMidSel,]

estimMC(as.numeric(BV$BVvalueMeas),
        BV$BVnumSamp,
        BV$BVnumTotal, 
        method=unique(BV$BVselectMeth))
```

## Multi-level Multiple Count Estimator

First I'll make a few (2) functions to make checking results easier.
```{r}
# a few convenience functions to check results
check<-function(x,e, name ="", digits=2, show=F){
  if(show){
    if(round(x,digits*2) != round(e,digits*2)){
      warning(paste(name,"expected:", round(e, digits), "!=", round(x, digits)),
              call. = F)
    }else{
      cat(paste(name,"expected:", round(e, digits), "==", round(x, digits), "\n"))
    }
  }else{
    
    testthat::expect_equal(x,e)
    }
}
warning("The expected variances are likely wrong for SRSWR and SRSWOR!", call. = F)

checkEstimates <- function(tblName, hd, startEstim, propSampled, res, ...){
  Ty <- paste0(tblName, "y")
  numStages <- which(names(hd) == tblName) #from A to B
  prevRows <- nrow(hd[[1]])^(numStages-2)
  prevID <- paste0(names(hd)[numStages-1],"id")
  
  
 
  b <- hd[[tblName]][hd[[tblName]][[prevID]] %in% c(1:prevRows), ]
  #TODO the variance checks might be misleading repair
  if(propSampled !=1){
    }
  
  expTotal <- sum(b[[Ty]])*((1/propSampled)^numStages)
  expVar <- ifelse(propSampled == 1, 0, var(b[[Ty]]))
  expVarTot <- expVar * ((1/propSampled)^numStages)
  check(res$estim$est.mean, mean(b[[Ty]]), "Mean", ...)
  check(res$estim$var.mean, expVar, "Var mean", ...)
  check(res$estim$est.total, expTotal,"Total",  ...)
  check(res$estim$var.total, expVarTot, "Var total", ...)
}

```

### Simulated data

```{r}
#keep results consistent
set.seed(1234)
```


#### CENSUS

```{r}

propSampled <- 1
hd<-generateTestTbls(LETTERS[1:5], propSamp = propSampled)
startEstim <- list(parentIdCol = "Aid", ids=c(1))

for(L in LETTERS[2:5]){
  cat(paste0("level ", L, ":\n"))
  Ty <- paste0(L, "y")
  res<-doMultiStageEstimation(tbls=hd, startEstim, target = Ty)
  checkEstimates(L, hd, startEstim, propSampled, res, show=F)
  cat("\n")
}

```



#### SRSWOR

##### All sampled
```{r}

propSampled <- 1
startEstim <- list(parentIdCol = "Aid", ids=c(1))
hd<-generateTestTbls(LETTERS[1:5], selMeth="SRSWOR",propSamp = propSampled)

for(L in LETTERS[2:5]){
  Ty <- paste0(L, "y")
  res<-doMultiStageEstimation(tbls=hd, startEstim, target = Ty)
  checkEstimates(L, hd, startEstim, propSampled, res, show=T)
  cat("\n")
}

```

##### 50% sampled

```{r}

propSampled <- 0.5
startEstim <- list(parentIdCol = "Aid", ids=c(1))
hd<-generateTestTbls(LETTERS[1:5], selMeth="SRSWOR",propSamp = propSampled)


for(L in LETTERS[2:5]){
  cat(paste0("level ", L, ":\n"))
  Ty <- paste0(L, "y")
  res<-doMultiStageEstimation(tbls=hd, startEstim, target = Ty)
  checkEstimates(L, hd, startEstim, propSampled, res, show=T)
  cat("\n")
}

```


##### 10% sampled

```{r}

propSampled <- 0.1
startEstim <- list(parentIdCol = "Aid", ids=c(1))
hd<-generateTestTbls(LETTERS[1:5], selMeth="SRSWOR",propSamp = propSampled, rows = 5)


for(L in LETTERS[2:5]){
  cat(paste0("level ", L, ":\n"))
  Ty <- paste0(L, "y")
  res<-doMultiStageEstimation(tbls=hd, startEstim, target = Ty)
  checkEstimates(L, hd, startEstim, propSampled, res, show=T)
  cat("\n")
}

```
##### Stats Book example 

Data and expected results from https://online.stat.psu.edu/stat506/lesson/9/9.1

A restaurant chain wants to estimate the average employee satisfaction with their job (the scale is from 1 to 7). They have 120 restaurants the total number of employees in the chain is 6860. They use simple random sampling (without replacement) to sample 10 restaurants. They then use simple random sampling (without replacement) to sample and interview about 20% of the employees in those restaurants. 
First let's make a RDBES data like object from the availabe data.

```{r}
rdf <- generateTestTbls(c("Restaurants"), rows=10, propSamp=1/12, selMeth = "SRSWOR")

employeeSampled <- list(
c(5, 7, 6, 5, 4, 7, 6, 6, 4, 5),
c(7, 7, 7, 6, 5, 4, 7, 7, 6, 6),	
c(5, 6, 5, 6, 4, 5, 6, 5, 4, 5, 4, 6, 5, 6)	,
c(6, 5, 7, 6, 7, 6, 5, 7, 5, 7, 6, 5, 7, 6),	
c(4, 5, 4, 5, 5, 6, 5, 4, 4, 4)	,
c(5, 7, 6, 7, 4, 3, 1, 5, 4, 6, 4, 5),	
c(7, 6, 7, 7, 6, 6, 5, 7),	
c(6, 6, 5, 4, 6, 7, 5, 5, 7, 6, 5),
c(7, 6, 5, 4, 6, 5, 7, 4, 3, 6, 5, 7),	
c(7, 6, 6, 5, 7, 3, 5, 4, 5)
)
employeeTotals <- c(54, 48, 68, 70, 52, 62, 41, 53, 64, 43)
employeeData <- list(values = employeeSampled, totals = employeeTotals)


makeCustomTestData<-function(x, data, name="Employees",
                             prevTblName = "Restaurants",
                             selMeth = "SRSWOR"){

tx <- generateTestTbls(c(name), 
                       rows=length(data$values[[x]]),
                       propSamp=length(data$values[[x]])/data$totals[x],
                       selMeth = selMeth)[[1]]
tx[,paste0(name, "y"):= data$values[[x]]]
tx[,paste0(prevTblName, "id") := x]
tx
}
edf <- do.call(rbind, lapply(1:length(employeeTotals), makeCustomTestData,
                                      data = employeeData))
edf[,Employeesid := 1:nrow(edf)]
rdf$Employees <- edf
```

```{r}
sbRes <- doMultiStageEstimation(tbls=rdf,
                                list(parentIdCol = "Restaurantsid", ids=1:10),
                                target = "Employeesy")
cat("Mean ")
 cat(sbRes$estim$est.mean)
cat("\n\tVar ")
 cat(sbRes$estim$var.mean)
 
cat("\nTotal ")
 cat(sbRes$estim$est.total)
cat("\n\tVar ")
 cat(sbRes$estim$var.total)
```

The expected mean and its variance for **ratio estimation** are 5.48 and 0.029. 
The expected total and its variance for **unbiased estimation** are 36471.5 and 3375.61. 


#### SRSWR
##### All sampled
```{r}
set.seed(1234)
propSampled <- 1
startEstim <- list(parentIdCol = "Aid", ids=c(1))
hd<-generateTestTbls(LETTERS[1:5], selMeth="SRSWR",propSamp = propSampled)

for(L in LETTERS[2:5]){
  cat(paste0("level ", L, ":\n"))
  Ty <- paste0(L, "y")
  res<-doMultiStageEstimation(tbls=hd, startEstim, target = Ty)
  checkEstimates(L, hd, startEstim, propSampled, res, show=T)
  cat("\n")
}

```

##### 50% sampled

```{r}
set.seed(1234)
propSampled <- 0.5
startEstim <- list(parentIdCol = "Aid", ids=c(1))
hd<-generateTestTbls(LETTERS[1:5], selMeth="SRSWR",propSamp = propSampled)


for(L in LETTERS[2:5]){
  cat(paste0("level ", L, ":\n"))
  Ty <- paste0(L, "y")
  res<-doMultiStageEstimation(tbls=hd, startEstim, target = Ty)
  checkEstimates(L, hd, startEstim, propSampled, res, show=T)
  cat("\n")
}

```

##### 10% sampled

```{r}
propSampled <- 0.1
startEstim <- list(parentIdCol = "Aid", ids=c(1))
hd<-generateTestTbls(LETTERS[1:5], selMeth="SRSWR",propSamp = propSampled, rows=5)

for(L in LETTERS[2:5]){
  cat(paste0("level ", L, ":\n"))
  Ty <- paste0(L, "y")
  res<-doMultiStageEstimation(tbls=hd, startEstim, target = Ty)
  checkEstimates(L, hd, startEstim, propSampled, res, show=T)
  cat("\n")
}

```


### Actual data


For lower hierarchy tables the number of sampled and measured total 
```{r}
estimTables <- tablesInRDBESHierarchies$H1[3:9]
estimTables
```   
```{r}
#writexl::write_xlsx(h1d[estimTables], "h1_exmaple.xlsx")
```


```{r}
head(h1d[[estimTables[1]]])
```


So we are estimating for a single Vessel the "BVvalueMeas" 

```{r}
startEstim <- list(parentIdCol = "VSid", ids=c(4874))
res<-doMultiStageEstimation(tbls=h1d[estimTables], startEstim, target = "BVvalueMeas")

warning("Variance is not corrected for  upper levels for variance correctly")
res$estim$est.mean
res$estim$var.mean
res$estim$est.total
res$estim$var.total
```

As we have sampled all items in this level we can see what the mean looks like in the actual data
```{r}
mean(as.numeric(h1d$BV[BVid %in% res$ids, BVvalueMeas]))
var(as.numeric(h1d$BV[BVid %in% res$ids, BVvalueMeas]))
sum(as.numeric(h1d$BV[BVid %in% res$ids, BVvalueMeas]))
```

In any case all of the previous stages are included hierarchically in the result. What is needed is the probability matrix for variance and total estimation at the last level. For the 2. level the PI is:
```{r}
res$prevStage$prevStage$prevStage$prevStage$prevStage$tbl
res$prevStage$prevStage$prevStage$prevStage$prevStage$estim$PI

```
It seems that for SRS the PI is homogeneous so can be converted to single number (both for SRSWR and SRSWOR) Let's see also the table as it looks at second level

```{r}
ids <- res$prevStage$prevStage$prevStage$prevStage$prevStage$ids
tblID <- res$prevStage$prevStage$prevStage$prevStage$prevStage$tbl
idCol <- res$prevStage$prevStage$prevStage$prevStage$prevStage$parentIdCol
tbl<-h1d[[tblID]]
tbl[get(idCol) %in% ids,]
```


```{r}
#END
```

